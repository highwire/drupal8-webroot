[
    {
        "policyId": "ecommerce",
        "name": "ecommerce",
        "policyType": "xslt",
        "url": "http://staticfs.highwire.org/platform/xsl/AtomEntryToECommResource.xslt",
        "format": "xml",
        "source": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- TODO: done? -->\n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:nlm=\"http://schema.highwire.org/NLM/Journal\" xmlns:c=\"http://schema.highwire.org/Compound\" xmlns:atom=\"http://www.w3.org/2005/Atom\" xmlns:hpp=\"http://schema.highwire.org/Publishing\" xmlns:app=\"http://www.w3.org/2007/app\" xmlns:l=\"http://schema.highwire.org/Linking\" xmlns:r=\"http://schema.highwire.org/Revision\" xmlns:hwp=\"http://schema.highwire.org/Journal\" xmlns=\"http://schema.highwire.org/eCommerce\" xmlns:ec=\"http://schema.highwire.org/eCommerce\" version=\"3.0\" exclude-result-prefixes=\"#all\"\n>\n  <xsl:output method=\"xml\" encoding=\"utf-8\" omit-xml-declaration=\"yes\" indent=\"no\"/>\n  \n  <xsl:param name=\"acs-base-uri\" select=\"'http://atom-collections-alpha.highwire.org/springer/content/atom'\" />\n  \n  <xsl:template match=\"/\" as=\"element(ec:resource)\">\n    <xsl:apply-templates select=\"if (exists(./atom:entry/c:parent)) \n        then ./atom:entry \n        else doc(resolve-uri(concat(./atom:entry/atom:link[@rel='self']/@href, '?with-ancestors=yes'), base-uri(.)))/atom:entry\"\n         />\n  </xsl:template>\n    \n  <xsl:template match=\"atom:entry\" as=\"element(ec:resource)\">\n    <xsl:variable name=\"selfUri\" select=\"atom:link[@rel='self']/@href\"/>\n    \n    <resource uri=\"{$selfUri}\" id=\"{atom:id/text()}\" \n      role=\"{atom:category[@scheme eq 'http://schema.highwire.org/Publishing#role']/@term}\" \n      epub-date=\"{ec:epub-date(.)}\" ppub-date=\"{ec:ppub-date(.)}\">\n      <xsl:if test=\"not(empty(ec:role-type(.)))\">\n        <xsl:attribute name=\"role-type\" select=\"ec:role-type(.)\"/>\n      </xsl:if>\n      <title><xsl:value-of select=\"atom:title\"/></title>\n      \n      <!-- public identifiers that content-id or content-bundles might nominate -->\n      <xsl:apply-templates \n        select=\"nlm:pub-id[@pub-id-type=('hwp', 'doi', 'issn', 'eissn', 'isbn', 'eisbn')]\"\n        />\n      \n      <!-- non-public identifiers that legacy subscription or privilege-sets might nominate -->\n      <xsl:apply-templates \n        select=\"(nlm:pub-id[@hwp:sub-type=('pisa-master','pisa')])[1]\"\n        />\n      \n      <!-- interesting categories, removed any redundant to data placed elsewhere -->\n      <xsl:for-each \n        select=\"atom:category[not(@scheme=(\n          'http://schema.highwire.org/Linking/External',\n          'http://schema.highwire.org/Publishing#role',\n          'http://schema.highwire.org/ItemSet/Item#type')\n          )]\">\n        <category scheme=\"{@scheme}\" term=\"{@term}\"/>\n      </xsl:for-each>\n      \n      <!-- interesting variants, removed any Atomstore atrifacts -->\n      <xsl:for-each \n        select=\"atom:link[@rel='alternate' and not(@c:role = (\n          'http://schema.highwire.org/Publishing/builtin')\n          )]\">\n        <variant role=\"{replace(@c:role, 'http://schema.highwire.org/variant/', '')}\" type=\"{@type}\" lang=\"{if (@hreflang) then @hreflang else 'en'}\" uri=\"{@href}\"/>\n      </xsl:for-each>\n            \n      <!-- include all ancestors and their public identifiers -->\n      <!-- making the intent clear, don't get your parent is it's the service root -->\n      <xsl:if test=\"not(c:parent[@xml:base eq '/svc.atom'])\">\n        <xsl:apply-templates select=\"c:parent\"/>\n      </xsl:if>\n    \n      <!-- include all Atom Collections, whether directly or indirectly assigned -->\n      <xsl:variable name=\"acs-member-query\" select=\"concat($acs-base-uri, '?member=', $selfUri)\" />\n      <xsl:variable name=\"categories\" select=\"if (doc-available($acs-member-query)) then doc($acs-member-query)/atom:feed/atom:entry/atom:category else ()\" />\n      <xsl:for-each select=\"$categories\">\n        <collection scheme=\"{@scheme}\" term=\"{@term}\"></collection>\n      </xsl:for-each>\n    </resource>\n  </xsl:template>\n\n  <!-- get ancestors until we hit the service atom -->\n  <xsl:template match=\"c:parent\" as=\"element(ec:ancestor)+\">\n    <ancestor uri=\"{@xml:base}\" \n      role=\"{atom:category[@scheme eq 'http://schema.highwire.org/Publishing#role']/@term}\">\n      <xsl:if test=\"not(empty(ec:role-type(.)))\">\n        <xsl:attribute name=\"role-type\" select=\"ec:role-type(.)\"/>\n      </xsl:if>\n      <xsl:apply-templates \n        select=\"nlm:pub-id[@pub-id-type=('hwp', 'doi', 'issn', 'eissn', 'isbn', 'eisbn')]\"\n        />\n      <xsl:if test=\"(c:parent[@xml:base eq '/svc.atom']) and not(exists(nlm:pub-id[@pub-id-type='hwp']))\">\n        <identifier type=\"hwp\" value=\"{atom:id}\"/>\n      </xsl:if>\n    </ancestor>\n    \n    <!-- making the intent clear, don't get your parent is it's the service root -->\n    <xsl:if test=\"not(c:parent[@xml:base eq '/svc.atom'])\">\n      <xsl:apply-templates select=\"c:parent\"/>\n    </xsl:if>\n  </xsl:template>\n  \n  <!-- get all the public identifiers we're ever going to use to match license rules against -->\n  <xsl:template match=\"nlm:pub-id[@pub-id-type=('hwp', 'doi', 'issn', 'eissn', 'isbn', 'eisbn')]\" \n    as=\"element(ec:identifier)\">\n    <identifier type=\"{@pub-id-type}\" value=\"{text()}\"/>\n  </xsl:template>\n  \n  <!-- get all the public identifiers we're ever going to use to match legacy subscriptions against -->\n  <xsl:template match=\"nlm:pub-id[@hwp:sub-type=('pisa','pisa-master')]\" \n    as=\"element(ec:identifier)\">\n    <identifier type=\"hwp\" value=\"{substring-after(text(), ';')}\"/>\n  </xsl:template>\n  \n  <!-- get the model-specific type, if any, might be a 'chapter' or 'part'  -->\n  <xsl:function name=\"ec:role-type\" as=\"xs:string?\">\n    <xsl:param name=\"atom\" as=\"element()\"/>\n    <xsl:for-each select=\"$atom\">\n      <xsl:choose>\n        <xsl:when test=\"exists(@nlm:article-type)\">\n          <xsl:value-of select=\"@nlm:article-type\"/>\n        </xsl:when>\n        <xsl:when test=\"exists(atom:category[@scheme eq 'http://schema.highwire.org/Publishing#subtype'])\">\n          <xsl:value-of select=\"replace(atom:category[@scheme eq 'http://schema.highwire.org/Publishing#subtype']/@term, 'http://schema.highwire.org/Journal/Fragment#', '')\"/>\n        </xsl:when>\n        <xsl:when test=\"exists(atom:category[@scheme eq 'http://schema.highwire.org/ItemSet/Item#type'])\">\n          <xsl:value-of select=\"(atom:category[@scheme eq 'http://schema.highwire.org/ItemSet/Item#type']/@term)\"/>\n        </xsl:when>\n        <xsl:otherwise/>\n      </xsl:choose>\n    </xsl:for-each>\n  </xsl:function>\n  \n  <!-- make sure that all dates are complete with no infered timezone -->\n  <xsl:function name=\"ec:dateTime\" as=\"xs:dateTime\">\n    <xsl:param name=\"input\" as=\"xs:string\"/>\n    <xsl:choose>\n      <xsl:when test=\"$input castable as xs:dateTime\">\n        <xsl:sequence select=\"xs:dateTime($input)\"/>\n      </xsl:when>\n      <xsl:when test=\"$input castable as xs:date\">\n        <xsl:sequence select=\"xs:dateTime(xs:date($input))\"/>\n      </xsl:when>\n      <xsl:when test=\"$input castable as xs:gYearMonth\">\n        <xsl:sequence select=\"xs:dateTime(xs:date(string-join(($input,'01'),'-')))\"/>\n      </xsl:when>\n      <xsl:when test=\"$input castable as xs:gYear\">\n        <xsl:sequence select=\"xs:dateTime(xs:date(string-join(($input,'01','01'),'-')))\"/>\n      </xsl:when>\n      <xsl:otherwise>\n        <xsl:message select=\"'Cannot create xs:dateTime from:',$input\"/>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:function>\n  \n  <!-- get the earliest date this resource (any version of it) was published online -->\n  <xsl:function name=\"ec:epub-date\" as=\"xs:dateTime\">\n    <xsl:param name=\"atom\" as=\"element(atom:entry)\"/>\n    <xsl:for-each select=\"$atom\">\n      <xsl:sequence select=\"ec:dateTime(( nlm:pub-date[@pub-type eq 'epub']/@hwp:start,          nlm:pub-date[@pub-type eq 'epub-version']/@hwp:start, nlm:pub-date[@pub-type eq 'epub-original']/@hwp:start, nlm:pub-date[@pub-type eq 'epub-ppub']/@hwp:start,          string(ec:ppub-date(.)) )[1])\"/>\n    </xsl:for-each>\n  </xsl:function>\n  \n  <!-- get the date-of-record this resource was published in print, whatever that means -->\n  <xsl:function name=\"ec:ppub-date\" as=\"xs:dateTime\">\n    <xsl:param name=\"atom\" as=\"element(atom:entry)\"/>\n    <xsl:for-each select=\"$atom\">\n      <xsl:sequence select=\"ec:dateTime(( nlm:pub-date[@pub-type eq 'ppub']/@hwp:start,          nlm:pub-date[@pub-type eq 'collection']/@hwp:start, nlm:pub-date[@pub-type eq 'epub-ppub']/@hwp:start, nlm:pub-date[@pub-type eq 'epub-original']/@hwp:start,          atom:published, atom:updated)[1])\"/>\n    </xsl:for-each>\n  </xsl:function>\n  \n</xsl:stylesheet>\n",
        "signature": "304b562a09ed975835d3011df2869328",
        "mimeTypes": [
            "application/vnd.hw.ecommerce+xml"
        ],
        "newMimeType": null,
        "corpusList": [],
        "newCorpus": null,
        "updatedDate": 1505508261425,
        "enable": true,
        "ignorePaths": null,
        "inclusionPaths": null,
        "new": false,
        "id": "4c0cc640-98ce-11e7-8b66-1195de1ee295"
    }
]
