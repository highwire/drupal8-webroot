<?php

/**
 * @file
 * Contains \Drupal\complex_field\Plugin\Field\FieldType\ComplexFieldItemBase.
 */

namespace Drupal\complex_field\Plugin\Field\FieldType;

use Drupal\complex_field\Exception\NotImplementedException;
use Drupal\complex_field\Mocks\MockedFieldStorageDefinition;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Field\FieldItemBase;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\TypedData\DataDefinitionInterface;
use Drupal\Core\TypedData\TypedDataInterface;


/**
 * A field item that holds multiple sub-elements.
 *
 * Module authors that want to utilize this functionality should extend this class
 * and override ::getSubelements() and ::getConstraints(). Note that the field
 * widget is partially autogenerated from getSubelements().
 *
 * @ingroup field_types
 */
class ComplexFieldItemBase extends FieldItemBase implements ComplexFieldItemInterface {

  /**
   * Return the list of fields this Complex Field should use.
   *
   * Other FieldItemInterface outputs are automatically generated based on this list.
   *
   * WARNING: After a field type based on this class has been created, DO NOT
   * change the output of this function. Severe data loss, unimaginable sadness,
   * and riots in the street will follow.
   *
   * Seriously. Don't do it.
   *
   * @return array
   *   An array of data describing your subfields. Example:
   *   return [
   *     'person' => [
   *       'label' => new TranslatableMarkup('Person'),
   *       'plugin' => 'entity_reference',
   *       'widget' => 'entity_reference_autocomplete',
   *       'storage_settings' => [
   *         'target_type' => 'node',
   *       ]
   *     ],
   *     'role' => [
   *       'label' => new TranslatableMarkup('Role'),
   *       'plugin' => 'string',
   *       'widget' => 'text_textfield',
   *       'storage_settings' => [
   *         'length' => 255,
   *       ],
   *       'widget_settings' => [
   *         'some_value' => 255,
   *         'something_else' => "my string",
   *       ],
   *     ],
   *   ];
   */
  public static function getSubelements() {
    throw new NotImplementedException("::getSubelements");
  }

  /**
   * Gets data for a sub-element.
   *
   * @param string $type
   *   The type of data to retrieve. One of "properties" or "schema".
   *
   * @return mixed
   */
  public static function getSubelementData($type) {
    // Get the subelement definitions.
    $subelements = static::getSubelements();

    // @todo Figure out how to inject this dependency. ::create() isn't called on FieldItem plugins.
    /** @var \Drupal\complex_field\PluginDataLoader $data_loader */
    $data_loader = \Drupal::service('complex_field.plugin_data_loader');

    $data = [];

    // Loop through our configured sub-elements.
    foreach ($subelements as $element_name => $configuration) {

      // Use a mocked field storage definition for each sub-element to satisfy the type hinting.
      $mocked_field_storage_definition = new MockedFieldStorageDefinition();
      $mocked_field_storage_definition->setSettings($configuration['storage_settings']);

      switch ($type) {
        // ::propertyDefinitions()
        case "properties":
          // Bring in each of the property definitions prefixed by $element_name.
          $subelement_properties = $data_loader->getFieldTypePropertyDefinitions(
            $configuration['plugin'],
            $mocked_field_storage_definition
          );
          foreach ($subelement_properties as $name => $value) {
            $data[$element_name . '_' . $name] = $value;
          }
          break;

        // ::schema()
        case "schema":
          $subelement_schema = $data_loader->getFieldTypeSchemaDefinition(
            $configuration['plugin'],
            $mocked_field_storage_definition
          );
          // Are there any field types that don't have a columns key in their schema?
          // There shouldn't be, but just to be safe...
          if (!isset($subelement_schema['columns'])) {
            continue;
          }

          // @todo Support schema indexes. Implementers can add indexes as they see fit.
          // Prefix subfield columns with the name of this subelement.
          foreach ($subelement_schema["columns"] as $column_name => $column_config) {
            $data['columns'][$element_name . '_' . $column_name] = $column_config;
          }
          break;

        default:
          throw new NotImplementedException("Subelement data of type {$type}");
          break;
      }
    }

    return $data;
  }

  /**
   * {@inheritdoc}
   */
  public static function propertyDefinitions(FieldStorageDefinitionInterface $field_definition) {
    return static::getSubelementData('properties');
  }

  /**
   * {@inheritdoc}
   */
  public static function schema(FieldStorageDefinitionInterface $field_definition) {
    return static::getSubelementData('schema');
  }

  /**
   * {@inheritdoc}
   */
  public static function mainPropertyName() {
    // Nobody using this class is ever going to have a single element field.
    // If you're using this class and you have a single element field, you're
    // a) doing it wrong and b) masochistic. Seriously, why are you using this?
    return NULL;
  }

  /**
   * {@inheritdoc}
   */
  public function getConstraints() {
    // @todo Gather constraints from plugin definition annotation
    //  (see parent::getConstraints())
    // @todo Gather constraints from each subelement plugin class (requires
    //  creating instances of the plugins which is more work than it's worth).
    // For now, just throw an exception. Implementers need to provide their own
    // constraints or explicitly opt-out by overriding the function and returning
    // an empty array.
    throw new NotImplementedException("::getConstraints()");
  }

  /**
   * {@inheritdoc}
   */
  public static function generateSampleValue(FieldDefinitionInterface $field_definition) {
    // @todo Support generating random values for all subelements.
  }
}
